> ## 类型兼容性 

 TypeScript里的类型兼容性是基于结构子类型的。 结构类型是一种只使用其成员来描述类型的方式。 

* Review接口学习代码

```typescript
interface IUser {
    name: string;
    age: number;
}

const getUserInfo = (user: IUser): string => {
    return `name: ${user.name}, age: ${user.age}`;
};

let jason = { name: 'jason', age: 30, from:'cn', tset: 4 }
//这里jason object 有两个额外属性,但并不会引发错误。只有目标属性（这里是Iuser）的成员会被一一检查是否兼容
//这个比较是递归进行的，检查每个成员及子成员
getUserInfo(jason);

```

除去函数，单看变量的类型兼容

```typescript

interface IUser {
    name: string;
    age: number;
}

let x: IUser;
x = { name: 'test', age: 0 }  // pass
x = {name:'test' , age:0 , other:'test'}  //error

let y = { name: 'test', age: 1, other: 'test' }

x = y
//此时赋值并不会引发错误，y给x赋值时已经符合x的接口约定。会判断为两个变量【类型兼容】
//因为比较是根据接口约定递归进行，name与age符合，并不会因为额外的other属性引发错误

```

* 开始

 Type Script结构化类型系统的基本规则是，如果`x`要兼容`y`，那么`y`至少具有与`x`相同的属性。

```typescript
interface Named {
    name: string;
}

let x: Named;
// y's inferred type is { name: string; location: string; }
let y = { name: 'Alice', location: 'Seattle' };
x = y;
```

 这里要检查`y`是否能赋值给`x`，编译器检查`x`中的每个属性，看是否能在`y`中也找到对应属性。 在这个例子中，`y`必须包含名字是`name`的`string`类型成员。`y`满足条件，因此赋值正确。 



 检查函数参数时使用相同的规则： 

```typescript
function greet(n: Named) {
    console.log('Hello, ' + n.name);
}
greet(y); // OK
```

注意，`y`有个额外的`location`属性，但这不会引发错误。 只有目标类型（这里是`Named`）的成员会被一一检查是否兼容。

这个比较过程是递归进行的，检查每个成员及子成员。



* 比较两个函数

 相对来讲，在比较原始类型和对象类型的时候是比较容易理解的，问题是如何判断两个函数是兼容的。 下面我们从两个简单的函数入手，它们仅是参数列表略有不同： 

```typescript
let x = (a: number) => 0;
let y = (b: number, s: string) => 0;

y = x; // OK
x = y; // Error
```

要查看`x`是否能赋值给`y`，首先看它们的参数列表。 `x`的每个参数必须能在`y`里找到对应类型的参数。 注意的是参数的名字相同与否无所谓，只看它们的类型。 这里，`x`的每个参数在`y`中都能找到对应的参数，所以允许赋值。

第二个赋值错误，因为`y`有个必需的第二个参数，但是`x`并没有，所以不允许赋值。

你可能会疑惑为什么允许`忽略`参数，像例子`y = x`中那样。 原因是忽略额外的参数在JavaScript里是很常见的。 例如，`Array#forEach`给回调函数传3个参数：数组元素，索引和整个数组。 尽管如此，传入一个只使用第一个参数的回调函数也是很有用的：

```typescript
let items = [1, 2, 3];

// Don't force these extra arguments
items.forEach((item, index, array) => console.log(item));

// Should be OK!
items.forEach((item) => console.log(item));
```

 下面来看看如何处理返回值类型，创建两个仅是返回值类型不同的函数： 

```typescript
let x = () => ({name: 'Alice'});
let y = () => ({name: 'Alice', location: 'Seattle'});

x = y; // OK
y = x; // Error, because x() lacks a location property
```

 类型系统强制源函数的返回值类型必须是目标函数返回值类型的子类型。 